<html>
<head><title>KGI IRC meeting log</title></head>
<body bgcolor="white">
[23:01] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: I know that, because I prepare the "reboot" command on a different console than I insmod the Rage.o module. :)<br />
[23:01] &lt;<font color="blue">skids</font>&gt; <skids> Should we start with current state, or immediate future plans?<br />
[23:01] &lt;<font color="red">philbo</font>&gt; <philbo> bughunter: hehe. good strategy. We still should fix it ASAP.<br />
[23:01] &lt;<font color="brown">Foske</font>&gt; <Foske> current state I guess... <br />
[23:02] &lt;<font color="brown">Foske</font>&gt; <Foske> where are we now ?<br />
[23:02] &lt;<font color="maroon">cow</font>&gt; <cow> philbo, np<br />
[23:03] &lt;<font color="brown">Foske</font>&gt; <Foske> and... what is wrong at the moment<br />
[23:04] &lt;<font color="brown">Foske</font>&gt; <Foske> guess not<br />
[23:04] &lt;<font color="blue">skids</font>&gt; <skids> WRT to basic framework/modesetting the open issues I remeber are these:<br />
[23:04] &lt;<font color="maroon">cow</font>&gt; <cow> current state: console handling (focus et al) needs brushing<br />
[23:04] &lt;<font color="blue">skids</font>&gt; <skids> 1) display vs. image for multi-port cards.<br />
[23:05] &lt;<font color="blue">skids</font>&gt; <skids> 2) Any needed meta-language/core system enhancements for DDC<br />
[23:05] &lt;<font color="blue">skids</font>&gt; <skids> 3) Unifying the monitor drivers<br />
[23:06] &lt;<font color="brown">Foske</font>&gt; <Foske> the most important imho is 1).. or : the possible need to reconstruct the kgi core<br />
[23:06] &lt;<font color="blue">skids</font>&gt; <skids> and 4) replacing MMAP offset with IOCTL/MMAP combo.<br />
[23:06] &lt;<font color="red">philbo</font>&gt; <philbo> skids: 4 is done.<br />
[23:07] &lt;<font color="blue">skids</font>&gt; <skids> philbo: cool!<br />
[23:07] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: In CVS or in your working tree?<br />
[23:07] &lt;<font color="brown">Foske</font>&gt; <Foske> in cvs already ?<br />
[23:07] &lt;<font color="red">philbo</font>&gt; <philbo> I would add 5) handle VT switching between console and graphics<br />
[23:08] &lt;<font color="red">philbo</font>&gt; <philbo> bughunter, Foske: in CVS, the kgi target for libggi uses it too.<br />
[23:08] &lt;<font color="brown">Foske</font>&gt; <Foske> isn't 5 supposed to work already for a long time ?<br />
[23:09] &lt;<font color="blue">skids</font>&gt; <skids> golbez: could you elaborate?<br />
[23:09] &lt;<font color="blue">skids</font>&gt; <skids> (and philbo)<br />
[23:09] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: nope. The map/unmap callbacks in graphic.c are currently NULL. Nobody really notices it because the keys for switching into graphic consoles aren't actually mapped anywhere in the current keymaps :-)<br />
[23:10] &lt;<font color="gray">golbez</font>&gt; <golbez> I think the focus should be stabalizing a single head setup so that a KGI kernel can be used for daily use.  Being able to switch between graphic and console vt is key to this.<br />
[23:10] &lt;<font color="brown">Foske</font>&gt; <Foske> ah ok<br />
[23:10] &lt;<font color="brown">Foske</font>&gt; <Foske> golbez: true, but multihead is getting more and more common, but it's okay with me if we drop that issue now<br />
[23:11] &lt;<font color="blue">skids</font>&gt; <skids> So mode set/restore is still working, we just need to implement unmap/map?<br />
[23:11] &lt;<font color="green">bughunter</font>&gt; <bughunter> golbez: For daily use, fixing bug #14 has priority #2 FOR ME (priority #1 is 5))<br />
[23:11] &lt;<font color="red">philbo</font>&gt; <philbo> The big question is what should be done? /dev/graphic will currently simply send a SIGBUG to unfocused devices. There's potential for fancy handling/virtualization there, but just putting the process to sleep is an adequate first attempt at a solution. XiGraphics server actually does this.<br />
[23:11] &lt;<font color="purple">curtisv</font>&gt; <curtisv> Will kgi have to support keyboard1+mouse1 --> display1 k2+m2-->d2 types of setup console wise?<br />
[23:12] &lt;<font color="brown">Foske</font>&gt; <Foske> imho, yes, curtis<br />
[23:12] &lt;<font color="brown">Foske</font>&gt; <Foske> but then again...<br />
[23:12] &lt;<font color="red">philbo</font>&gt; <philbo> curtisv: yes this kind of assignments of keyboards and mice is already in there and working.<br />
[23:12] &lt;<font color="brown">Foske</font>&gt; <Foske> kgi must be up and running first<br />
[23:13] &lt;<font color="blue">skids</font>&gt; <skids> curtisv: eventually, but I agree we should not divert our attention to this sort of thing as it distracts us from GPU issues which is kind of the whole point of KGI.<br />
[23:13] &lt;<font color="purple">curtisv</font>&gt; <curtisv> yes to all thx<br />
[23:13] &lt;<font color="brown">Foske</font>&gt; <Foske> so...<br />
[23:14] &lt;<font color="brown">Foske</font>&gt; <Foske> what is needed before we can say kgi is really usable...<br />
[23:14] &lt;<font color="brown">Foske</font>&gt; <Foske> bug #14 and 5)<br />
[23:14] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: and get rid of the red screen.<br />
[23:14] &lt;<font color="brown">Foske</font>&gt; <Foske> indeed<br />
[23:14] &lt;<font color="brown">Foske</font>&gt; <Foske> mode initialisation<br />
[23:14] &lt;<font color="gray">golbez</font>&gt; <golbez> yes, figure out what the hell the vga driver is doing to cause the red screen of death!<br />
[23:15] &lt;<font color="brown">Foske</font>&gt; <Foske> golbez: don't bother: if the vga driver behaves the same as the matrox driver, modesetting fixes everything<br />
[23:15] &lt;<font color="brown">Foske</font>&gt; <Foske> if not... DO bother<br />
[23:16] &lt;<font color="gray">golbez</font>&gt; <golbez> Foske: well, the matrox driver uses the vga driver for text (or I assume it does)<br />
[23:16] &lt;<font color="green">bughunter</font>&gt; <bughunter> nsouch: hi!<br />
[23:16] &lt;<font color="green">bughunter</font>&gt; <bughunter> nsouch: status of FreeBSD port?<br />
[23:16] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> hi there<br />
[23:16] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> slow progression :(, but effort maintained!<br />
[23:17] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: There's something definitely wrong with the vga-text driver. The red screen happens on *every* card. Across chipsets, everywhere. So I'm pretty sure it is a bug.<br />
[23:17] &lt;<font color="brown">Foske</font>&gt; <Foske> golbez: okay, but I don't see it as a major issue: kgi should set into an usable mode when initialized<br />
[23:17] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: the weird thing is that the only thing vga-text does is it read the contents of all vga registers. *read* only. <br />
[23:17] &lt;<font color="green">bughunter</font>&gt; <bughunter> nsouch: We just started to talk about how to fix the red screen of death caused by the VGA driver.<br />
[23:17] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: there are vgaregisters affected when reading others<br />
[23:17] &lt;<font color="blue">skids</font>&gt; <skids> Oh.  That sounds like a VGA DAC thing.<br />
[23:17] &lt;<font color="green">bughunter</font>&gt; <bughunter> nsouch: Do you get it under FreeBSD as well?<br />
[23:18] &lt;<font color="brown">Foske</font>&gt; <Foske> for example the ATC registers<br />
[23:18] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: hrm. that might be it then.<br />
[23:18] &lt;<font color="blue">skids</font>&gt; <skids> The DAC has a funky register that rotates addresses when you read it.<br />
[23:19] &lt;<font color="maroon">cow</font>&gt; <cow> note to monitor drivers: make monitor driver replaceable; refine .._timings and factor out type specific calcs; (collect common code in parts run through preprocessor -- perhaps not pretty but avoids loads of dup'ed code)<br />
[23:19] &lt;<font color="brown">Foske</font>&gt; <Foske> take a look at the flipflops reset by a read...<br />
[23:20] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: and unfortunately, mode setting doesn't quite fix it. Mode on a console is set only when the console is opened so if you replace a driver that is already driving a console kgi will check if the new driver can do console, but it won't exactly set it. (I think, I'll go look at the code again)<br />
[23:20] &lt;<font color="blue">skids</font>&gt; <skids> Anyway the proper code should be in a DAC_ins/DAC_outs function set somewhere, if it still exists.<br />
[23:20] &lt;<font color="blue">skids</font>&gt; <skids> HI rodolphe!<br />
[23:20] &lt;<font color="green">bughunter</font>&gt; <bughunter> ortalo: hi rodolphe!<br />
[23:21] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> hi rodolphe<br />
[23:21] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Hello everybody.<br />
[23:21] &lt;<font color="red">philbo</font>&gt; <philbo> cow: yes I agree. If the code is the same for all monitor drivers, replacing only the limits will be much easier.<br />
[23:21] &lt;<font color="maroon">cow</font>&gt; <cow> there's a difference between initial DAC settings between vga-driver and and vga-text.. is somebody aware of the meanings of the bits which are changed?<br />
[23:22] &lt;<font color="blue">skids</font>&gt; <skids> Anyway we know a probable cuase for the red screen or death, so we should move to another topic and bang it out later.<br />
[23:22] &lt;<font color="purple">curtisv</font>&gt; <curtisv> could I suggest that we make an online table of issues by priority in one axis and HW tested with in the other axis to cover the various issues as we fix em.  I can (eventually) test fixes on a number of systems.  This would be a good resource to keep me directed.<br />
[23:22] &lt;<font color="brown">Foske</font>&gt; <Foske> okay.. one last question: who is after this ?<br />
[23:23] &lt;<font color="purple">curtisv</font>&gt; <curtisv> (Be nice to have scripted tests for each issue as well)<br />
[23:23] &lt;<font color="gray">golbez</font>&gt; <golbez> Foske: you mean who will try to fix the red screen of death?<br />
[23:23] &lt;<font color="blue">skids</font>&gt; <skids> Well, cow's been doing the text console work lately, so he can pick my brain later.<br />
[23:23] &lt;<font color="brown">Foske</font>&gt; <Foske> yupz<br />
[23:24] &lt;<font color="brown">Foske</font>&gt; <Foske> ok. cow, skids, you are the red screen guys ?<br />
[23:24] &lt;<font color="blue">skids</font>&gt; <skids> OK.<br />
[23:24] &lt;<font color="brown">Foske</font>&gt; <Foske> okay.. the monitor issues<br />
[23:24] &lt;<font color="maroon">cow</font>&gt; <cow> i'll try<br />
[23:24] &lt;<font color="brown">Foske</font>&gt; <Foske> I got DDC 1 working, there is code for both the matrox and the mach32 drivers (where is the mach32 in cvs, by the way)<br />
[23:25] &lt;<font color="red">philbo</font>&gt; <philbo> Mach32?<br />
[23:25] &lt;<font color="gray">golbez</font>&gt; <golbez> mach8 too!<br />
[23:25] &lt;<font color="brown">Foske</font>&gt; <Foske> eh those ati cards ?<br />
[23:25] &lt;<font color="brown">Foske</font>&gt; <Foske> or am I wrong now ?<br />
[23:26] &lt;<font color="red">philbo</font>&gt; <philbo> skids: wow. that's old.<br />
[23:26] &lt;<font color="brown">Foske</font>&gt; <Foske> anyway...<br />
[23:26] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: Do you have the docs for them as well?<br />
[23:26] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: I have DDC for mach64.<br />
[23:26] &lt;<font color="blue">skids</font>&gt; <skids> Well VGADOC4b works fine for them up until about mach64 where it starts to miss details.<br />
[23:26] &lt;<font color="brown">Foske</font>&gt; <Foske> the principle of ddc1 works, all I need is a decent glue between the chipsets ddc io and the monitor driver<br />
[23:26] &lt;<font color="brown">Foske</font>&gt; <Foske> oh, mach64.. I was wrong there ;)<br />
[23:27] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: I didn't put it in cvs though because of the missing glue<br />
[23:27] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: Ah - modesetting with the DDC information is possible now?<br />
[23:27] &lt;<font color="brown">Foske</font>&gt; <Foske> not really<br />
[23:27] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Do you know if latest ATI chipsets (like Rage128 or Radeon) are compatible with the Mach & co.?<br />
[23:27] &lt;<font color="gray">golbez</font>&gt; <golbez> ortalo: don't think so<br />
[23:27] &lt;<font color="brown">Foske</font>&gt; <Foske> DDC returns timelists and ranges... philbo wrote a range--mode-setting (the multisync driver<br />
[23:28] &lt;<font color="brown">Foske</font>&gt; <Foske> but.. now everything has to be glued together<br />
[23:28] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: no they are not. mach8-32-64 were kind of incremental (even though the switch from io to mem based communication broke a lot of stuff) rage128 is the new generation and radeon and so on a very similar.<br />
[23:28] &lt;<font color="brown">Foske</font>&gt; <Foske> I proposed already that the timing formula calculation should be in an include file or general file, so all drivers can use those<br />
[23:29] &lt;<font color="blue">skids</font>&gt; <skids> Foske: a macro .h for timing formulas sounds like a very good thing (tm).<br />
[23:29] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> What do you mean by the timing formula?<br />
[23:29] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: can you continue glueing the monitor driver mess ?<br />
[23:30] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: you got a resolution, and the range a monitor can handle. now make timings out of that :)<br />
[23:30] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: OTOH if we just merged all the driver there's no need for include file, there would be only that file.<br />
[23:30] &lt;<font color="brown">Foske</font>&gt; <Foske> yupz.. but the DDC driver will be HUGE <br />
[23:30] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: the code would be the same for all drivers, the only thing that would change would be the limits, and the way they are obtained (hardcoded in the driver or implementation of DCC)<br />
[23:30] &lt;<font color="brown">Foske</font>&gt; <Foske> (now only DDC1 is implemented, and not even completely)<br />
[23:31] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: true, thus the calculation code should take a set of ranges as input value<br />
[23:32] &lt;<font color="blue">skids</font>&gt; <skids> philbo: well, timelist is slightly different, in that the limits are more strict/specific than mono/multisync<br />
[23:32] &lt;<font color="brown">Foske</font>&gt; <Foske> I got a huge problem with DDC2, but first let's tackle the generic problems<br />
[23:32] &lt;<font color="red">philbo</font>&gt; <philbo> skids: hrm. Maybe that could be part of the limits: tolerance.<br />
[23:32] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: what kind of pb?<br />
[23:33] &lt;<font color="blue">skids</font>&gt; <skids> philbo: right, besides in the case of LCD's with external monitor ports, the functionality kinda needs to be integrated anyway, so I'd say rolling timelist in with mono/multi would be good.<br />
[23:33] &lt;<font color="brown">Foske</font>&gt; <Foske> timelist means: this monitor can do this mode, that mode and that mode. range means: 30-70 KHz, 50-120 Hz Vsync , 0-120 MHz pixclock<br />
[23:34] &lt;<font color="maroon">cow</font>&gt; <cow> philbo, one file per calc-type which impls some let's say calculate_*(), or did you mean one monitor/calcs.c containing GTF down to timelist?<br />
[23:34] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch: I need to implement / interface a complete I2C driver<br />
[23:34] &lt;<font color="red">philbo</font>&gt; <philbo> cow: I meant one implementation of the monitor meta language.<br />
[23:34] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch : implement = HUGE code, interface = very OS dependant, and might not work on all platforms<br />
[23:34] &lt;<font color="red">philbo</font>&gt; <philbo> cow: replacing the metalanguage on the fly is nasty. Just changing the monitor limits might be better.<br />
[23:35] &lt;<font color="blue">skids</font>&gt; <skids> Sidenote: the monitor driver should export an informational element to user-space.<br />
[23:35] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: not at all, you just have to connect the chipset driver to linux / freebsd I2C framework<br />
[23:35] &lt;<font color="maroon">cow</font>&gt; <cow> philbo, wouldn't the calcs be hooked up somewhere below the meta-lang (wouldn't that be cleaner?)<br />
[23:35] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch: true, but the BSD framework differs from the Linux framework<br />
[23:36] &lt;<font color="brown">Foske</font>&gt; <Foske> cow, philbo: imho, the data is much too static at the moment<br />
[23:36] &lt;<font color="brown">Foske</font>&gt; <Foske> the metalanguage shouldn't be affected <br />
[23:37] &lt;<font color="red">philbo</font>&gt; <philbo> cow: well I don't know. Either the calcs are totally static and the limits are obtained dynamically, or the whole calculation can be changed on the fly. I don't know if it is really necessary though.<br />
[23:37] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: yes, and I2C control of the board seems really chipset dependent at least the initialisation<br />
[23:38] &lt;<font color="maroon">cow</font>&gt; <cow> philbo, hm. i did think that it was necessary, no?<br />
[23:38] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: that's right the data is too static. We'd need some sort of callback to get the data and this would be driver specific. DDC would get them from a monitor, other drivers would just return static data.<br />
[23:38] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch: and that initialisation can't be done when I hook up to the Linux I2c driver (doesn't know a I2C_init call)<br />
[23:39] &lt;<font color="brown">Foske</font>&gt; <Foske> maybe... we can generate one generic driver, that examines the data returned by the monitor specific part...<br />
[23:39] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: your ideas sound good<br />
[23:40] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Am I wrong or dynamic timing calculation is only useful if one unplugs a DDC monitor and plugs another one instead?<br />
[23:40] &lt;<font color="red">philbo</font>&gt; <philbo> cow: maybe, but I'm not sure. For things like monosync and timelist there is no real calculation needed. For anything else, there is really no standard the best the whole industry could come up with is GTF. I guess the only thing that isn't covered is a multisync monitor with precisely defined formula that isn't compatible with GTF. Is there such a thing?<br />
[23:40] &lt;<font color="blue">skids</font>&gt; <skids> IMO we need a diagram of the various subsystems and what metalanguages/structures they provide to each other.<br />
[23:40] &lt;<font color="blue">skids</font>&gt; <skids> Which we keep up to date and can be used to propose changes.<br />
[23:40] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: not really....<br />
[23:40] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: I agree.<br />
[23:41] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: what I miss at the moment is the option to set vsync rates together with the mode, but okay<br />
[23:41] &lt;<font color="red">philbo</font>&gt; <philbo> skids: yes yes<br />
[23:41] &lt;<font color="maroon">cow</font>&gt; <cow> i want to be able to change on the fly -while running an app- between monosync to timelist and vesa. if this doesn't work it's imho a bug<br />
[23:41] &lt;<font color="brown">Foske</font>&gt; <Foske> ah<br />
[23:41] &lt;<font color="brown">Foske</font>&gt; <Foske> welcome hunger !<br />
[23:41] &lt;<font color="darkcyan">hunger</font>&gt; <hunger> Hi<br />
[23:41] &lt;<font color="red">philbo</font>&gt; <philbo> cow: this will require re-setting mode.<br />
[23:41] &lt;<font color="darkcyan">hunger</font>&gt; <hunger> I hope you don't discuse secrets here;-)<br />
[23:42] &lt;<font color="brown">Foske</font>&gt; <Foske> hiunger: a log of all said before will be available after the meeting<br />
[23:42] &lt;<font color="red">philbo</font>&gt; <philbo> skids: I'll take care of that. I like pretty pictures :-)<br />
[23:42] &lt;<font color="maroon">cow</font>&gt; <cow> philbo, yes. that's what makes it not too appealing<br />
[23:43] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: I2C should not be so much code, you just have to read / write few registers. But yes, many OS dependent interfaces does not fit with the chipset driver API which is autonomous<br />
[23:43] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: that replugging a monitor is a nice feature you get for free when using dynamic data for mode calculations<br />
[23:43] &lt;<font color="green">bughunter</font>&gt; <bughunter> curtisv: Some days ago, you mentioned, you can make KGI working on a plasma display. Does it DDC, too?<br />
[23:44] &lt;<font color="green">bughunter</font>&gt; <bughunter> s/Does it DDC/Does it support DDC/<br />
[23:44] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: besides, the DDC driver doesn't know what monitor is connected till the data is there... so the ddc driver will have to adapt the data<br />
[23:44] &lt;<font color="brown">Foske</font>&gt; <Foske> and thus need dynamic data structs<br />
[23:44] &lt;<font color="red">philbo</font>&gt; <philbo> at any rate, is there a reason for making the *calculation code* changeable as opposed to changing only the *limits* (along with a method for obtaining them) ?<br />
[23:44] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch: I need to copy / pase most of i2c_algo_bit.c from the linux kernel<br />
[23:44] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Yes. But it's rare enough to wonder if dynamic calculations are really needed. (Especially if the user can do them via rmmod/insmod.)<br />
[23:45] &lt;<font color="brown">Foske</font>&gt; <Foske> eh ?<br />
[23:45] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> ortalo: are monitors really unpluggable? From HW spec point of view?<br />
[23:45] &lt;<font color="brown">Foske</font>&gt; <Foske> the calculation code isn't changable, only uses dynamic data !<br />
[23:45] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch : yes<br />
[23:45] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch: there is a PND Plug and Display standard<br />
[23:45] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: ok. then we agree.<br />
[23:46] &lt;<font color="blue">skids</font>&gt; <skids> philbo: Let's answer that question in the context of providing standard kernel console services only, as a user-space app with chipset specific knowlege can propose specific timings.<br />
[23:46] &lt;<font color="brown">Foske</font>&gt; <Foske> and... if the data doesn;t countain ranges, the mode calculation should use the timelist modes provided<br />
[23:46] &lt;<font color="brown">Foske</font>&gt; <Foske> this way, the monitor driver can handle any type of monitor<br />
[23:47] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Anyway, it seems to me that something more dynamic is needed (we see it via DDC), but maybe a totally dynamic driver (supporting hot-swapping etc.) is not so useful.<br />
[23:47] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: well... it is only a little step forward, but okay<br />
[23:47] &lt;<font color="brown">Foske</font>&gt; <Foske> that is for kgi 2.0<br />
[23:48] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: I wanted to give it a try with FBSD but could figure how to init I2C without kgi chipset init. I don't have KGI working yet...<br />
[23:48] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Well, if it is available, I will use it. (I tend to swap monitors a lot even if I know I shouldn't.)<br />
[23:48] &lt;<font color="red">philbo</font>&gt; <philbo> skids: hm. I don't think a user-space app should propose timings. Possibly a general hint about the refresh rate, but it should be the kernel that actually decides what gets set.<br />
[23:48] &lt;<font color="brown">Foske</font>&gt; <Foske> first get a monitor driver that acts like described<br />
[23:49] &lt;<font color="blue">skids</font>&gt; <skids> philbo: I think the app should be able to propose, and the in-kernel code then only has to validate so it is simpler.<br />
[23:49] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: user apps definitely should be able to propose a vsync, but thats all<br />
[23:49] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: each subsystem or just chipset and monitor?<br />
[23:49] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: might as well make it a non-specific meta language element... if a subsystem has nothing to offer it just hands nothing back.<br />
[23:50] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: you got my ideas about the generalized driver ?<br />
[23:51] &lt;<font color="brown">Foske</font>&gt; <Foske> bughunter: not at the moment :) the chipset driver generates a " monitor switched" event, and after that, the monitor driver has to redo ddc, and modesettiong has to start all over... KGI can't do that atm<br />
[23:51] &lt;<font color="red">philbo</font>&gt; <philbo> To get back to the main issue: what kind of an interface do we need for the dynamic obtaining of limits? Requirements are: it needs to be replaceable after the driver is loaded. It needs to be per monitor. It has to be able to hook it up to the chipset.<br />
[23:51] &lt;<font color="blue">skids</font>&gt; <skids> It simplifies the kernel driver's job.<br />
[23:51] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: answer:<br />
[23:51] &lt;<font color="brown">Foske</font>&gt; <Foske> a list of ranges and a list of timings<br />
[23:52] &lt;<font color="brown">Foske</font>&gt; <Foske> provided by the "specific" driver<br />
[23:52] &lt;<font color="blue">skids</font>&gt; <skids> philbo: how about a timing loop event that says "new limits have been found" followed by a top-down mode-rework.<br />
[23:52] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: Right that's the ultimate result. But what kind of interface would we need for actually getting them? GetLimits callback?<br />
[23:53] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> user-land app is not stupid, pcmcia is managed outside the kernel, the kernel driver only allow access to HW<br />
[23:53] &lt;<font color="maroon">cow</font>&gt; <cow> skids, i did something like this locally and it looks good to me<br />
[23:53] &lt;<font color="red">philbo</font>&gt; <philbo> skids: good thinking, integrating it into the timing loop would definitely be good.<br />
[23:53] &lt;<font color="brown">Foske</font>&gt; <Foske> sound good, but then (thinking about multihead) we would need: GetLimits (int head,...);<br />
[23:54] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: I was thinking of a function pointer for each monitor. (So that we can have a DDC monitor as well as a non DDC one at the same time -- a very likely situation)<br />
[23:54] &lt;<font color="brown">Foske</font>&gt; <Foske> sounds good...<br />
[23:55] &lt;<font color="blue">skids</font>&gt; <skids> Basically we just need to store the requested mode (not the eventually programmed mode) which I believe we already do (?) and then a mechanism for the subsystem to restart the timing loop.<br />
[23:56] &lt;<font color="blue">skids</font>&gt; <skids> (Plus we also probably need to freeze access to the hw accel/fb during the reporgram.)<br />
[23:56] &lt;<font color="brown">Foske</font>&gt; <Foske> that lock is definitely something we need<br />
[23:56] &lt;<font color="brown">Foske</font>&gt; <Foske> I need it for DDC1 too<br />
[23:57] &lt;<font color="maroon">cow</font>&gt; <cow> skids, yes. only one TC_RE per display at a time<br />
[23:57] &lt;<font color="blue">skids</font>&gt; <skids> Which brings us back to VC unmap... maybe a monitor switch should be essentially a vc switch from vc X TO vc X :-)<br />
[23:57] &lt;<font color="maroon">cow</font>&gt; <cow> s/TC_RE/TC_REINSTATE or RECHECK or whatever<br />
[23:58] &lt;<font color="brown">Foske</font>&gt; <Foske> skids: is an option<br />
[23:58] &lt;<font color="red">philbo</font>&gt; <philbo> cow: recheck sounds pretty good.<br />
[23:58] &lt;<font color="blue">skids</font>&gt; <skids> (Plus a double CTRL-ALT-FN will cause a mode reset, a feature I've always wanted :)<br />
[23:59] &lt;<font color="maroon">cow</font>&gt; <cow> (a nonstatic suicide(). well :)<br />
[00:00] &lt;<font color="blue">skids</font>&gt; <skids> OK, it sounds like locking up the accel/fb for VC switch and for modeset is a high priority item, to me.<br />
[00:00] &lt;<font color="red">philbo</font>&gt; <philbo> skids: I suppose it would be similar. From KGI point of view (as opposed to KGIM) the display has one big chunk of data for the mode which contains everything about it. So a recheck would just adjust this chunk of data (change the timings) and KGI could just reset the mode (just what happens during a vt switch)<br />
[00:01] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: accel/fb are mode resources. If the mode is not yet set, they are not available. So why this locking at modeset? Do you mean mode-re-set?<br />
[00:01] &lt;<font color="red">philbo</font>&gt; <philbo> skids: I don't really think we need a lock or anything, just implementing the map/unmap functions.<br />
[00:01] &lt;<font color="blue">skids</font>&gt; <skids> Cool, if it's already there, more power to steffen :-)<br />
[00:02] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: don't forget that kernel drivers are multientrant !<br />
[00:02] &lt;<font color="blue">skids</font>&gt; <skids> But we wouldn't want the conents of accel pipes or fb damaged if the new mode is not different...<br />
[00:02] &lt;<font color="green">bughunter</font>&gt; <bughunter> ortalo: A mode is always set. If it is not a graphic mode, then it is a text mode. :)<br />
[00:02] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> philbo: how would KGI decide to reset the mode? If limits are overan? If a better mode is available?<br />
[00:03] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> nsouch: if asked to by an authorized user app.<br />
[00:03] &lt;<font color="brown">Foske</font>&gt; <Foske> before you set a mode, accel must be idle, but in the meanwhile, the accel buffer can be filled and filled again<br />
[00:03] &lt;<font color="red">philbo</font>&gt; <philbo> nsouch: I don't know. Maybe DDC can tell you when the monitor changes?<br />
[00:03] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> NB: the driver must take care that the accel buffers get flushed correctly before changing the mode.<br />
[00:04] &lt;<font color="brown">Foske</font>&gt; <Foske> DDC can't... your chipset driver must detect a ramdac output error or something familiar<br />
[00:04] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> philbo: Everyone would expect mode downgrading if current mode is not supported by the newly plugged monitor<br />
[00:04] &lt;<font color="blue">skids</font>&gt; <skids> OK, someone needs to volunteer to make a step by step list of what needs to be done on VC switch/monitor change.<br />
[00:04] &lt;<font color="brown">Foske</font>&gt; <Foske> you can only detect monitor changing by polling on vsync<br />
[00:05] &lt;<font color="brown">Foske</font>&gt; <Foske> a job for me and philbo ?<br />
[00:05] &lt;<font color="red">philbo</font>&gt; <philbo> nsouch: that's ok for the user, but I wouldn't want the application to have to respond to mode changes it didn't initiate. Even if the newly rechecked mode is not the same the chipset should behave the same.<br />
[00:05] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> polling inside the kernel does not seem good to me :(<br />
[00:05] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: sounds good.<br />
[00:06] &lt;<font color="blue">skids</font>&gt; <skids> "polling" is fine if it is IRQ or tasklet driven.<br />
[00:06] &lt;<font color="blue">skids</font>&gt; <skids> How often do we need to poll to catch monitor switch, say, if a KVM is used?<br />
[00:06] &lt;<font color="red">philbo</font>&gt; <philbo> skids: right. I have a feeling some chipsets actually generate a special IRQ if the monitor is unplugged.<br />
[00:06] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> philbo: that's true<br />
[00:06] &lt;<font color="brown">Foske</font>&gt; <Foske> skids: every vsync is recommended by VESA<br />
[00:07] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> skids: I have currently W$ polling my CDROM and that irritates me :)<br />
[00:07] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: can be, though that isn't mandatory for P&D aware chipsets<br />
[00:07] &lt;<font color="blue">skids</font>&gt; <skids> OK, that makes retrace IRQ mandatory for guaranteed hotplug safety... a note for the tech docs.<br />
[00:08] &lt;<font color="brown">Foske</font>&gt; <Foske> skids: that note is a remark in the VESA DOCS already<br />
[00:08] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> philbo: at least then KGI should off the monitor as the monitor generally do when the card exceed their limits<br />
[00:09] &lt;<font color="blue">skids</font>&gt; <skids> Well, this is a good thing IMO, because it forces us to get those IRQ handlers written :-)<br />
[00:09] &lt;<font color="maroon">cow</font>&gt; <cow> speaking of tasklets.. currently console and keyboard is run through bottomhalves, which should be fixed. afaics a usable solution (for the lniux part) is not to be expected before 2.7 (spring/summer 2003, probably). what should we do about this?<br />
[00:09] &lt;<font color="red">philbo</font>&gt; <philbo> a quick scan of documentation for certain, further unspecified ATI chipsets, reveals that they do support IRQ on hotplug.<br />
[00:09] &lt;<font color="maroon">cow</font>&gt; <cow> linux, of course<br />
[00:10] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Concerning VC switch. What states should be saved by the driver? IMHO, VGA-text state should be saved nearly entirely (that's ~64ko, big, but well). In a graphics mode, I guess the accel engine internal state must be preserved but anything more is probably much bigger (well cursor shape excepted).<br />
[00:10] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> cow: of course<br />
[00:10] &lt;<font color="red">philbo</font>&gt; <philbo> cow: what exactly that useable solution is?<br />
[00:10] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, i don't think it's neccesary to save the font part, so it is 32k at worst, imo<br />
[00:11] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> cow: in FreeBSD you could have a dedicated kernel thread<br />
[00:11] &lt;<font color="maroon">cow</font>&gt; <cow> philbo, tasklets and queues<br />
[00:11] &lt;<font color="red">philbo</font>&gt; <philbo> cow: doesn't 2.4 have tasklets?<br />
[00:11] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: I think saving of the fb should be an optional feature that must be enabled by an app, if allowed by the sysadmin.  fb's are big these days but so is core RAM.<br />
[00:11] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> cow: I the font gets scrambled, the text head is unusable on restore! I'd rather loose the content of the screen than the font.<br />
[00:12] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: fbs are not as big as VRAM. Whatabout textures?<br />
[00:12] &lt;<font color="brown">Foske</font>&gt; <Foske> well.. more important to the question what you want saved is, what can the user level restore ?<br />
[00:12] &lt;<font color="blue">skids</font>&gt; <skids> WHich is why apps shouldn't ask KGI for more of the VRAM than they actually intend to use :-)<br />
[00:12] &lt;<font color="maroon">cow</font>&gt; <cow> philbo, yes. but i didn't want to fill in those bits for >=2.4.17 as it's supposed to be stable, and i can't guarantee that it will be right from the start<br />
[00:13] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Even if it sounds feasible nowadays to save the entire fb (or even the entire VRAM), I would not really go that way. Maybe fb(screen only) saving is feasible.<br />
[00:13] &lt;<font color="brown">Foske</font>&gt; <Foske> Unreal Tournament takes 2/3 seconds preloading all textures... donnow if that is what you want every time...<br />
[00:13] &lt;<font color="blue">skids</font>&gt; <skids> Well, that's why the app must request it; it would not be a default setting.<br />
[00:13] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Foske: Well, if the user VC-switched off, maybe he wanted that 2/3 seconds...<br />
[00:14] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, if font's get scrambled, userspace/ram-location is supposed to provide sane state, i guess<br />
[00:14] &lt;<font color="brown">Foske</font>&gt; <Foske> also true<br />
[00:14] &lt;<font color="brown">Foske</font>&gt; <Foske> and you shouldn't console switch when playing games ;)<br />
[00:14] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> cow: text-based app tends to be simple.<br />
[00:14] &lt;<font color="blue">skids</font>&gt; <skids> We also have the option of not saving the part of the fb that isn't used by text/fonts untilk a second graphical terminal is switched to.<br />
[00:15] &lt;<font color="brown">Foske</font>&gt; <Foske> naah<br />
[00:15] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: that's an optimization.<br />
[00:15] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> So what do we want to guarantee to applications.<br />
[00:15] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: Except at the Office when your boss enters the room :)<br />
[00:15] &lt;<font color="brown">Foske</font>&gt; <Foske> you can never know that you'll come back<br />
[00:15] &lt;<font color="blue">skids</font>&gt; <skids> And if we engineer things right, when a second app asks /dev/graphic for space it allocates portions of space that are unused in VRAM first.<br />
[00:15] &lt;<font color="brown">Foske</font>&gt; <Foske> immediately<br />
[00:15] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Personnally, I'd guarantee full state for VGA-text. First. What do you think?<br />
[00:15] &lt;<font color="blue">skids</font>&gt; <skids> I think that the "mandatory" KGI driver spec should not specify saving accel/fb content.<br />
[00:15] &lt;<font color="brown">Foske</font>&gt; <Foske> you switch to textmode: save only the part overwritten in texmode... switch on to ANOTHER graph mode... and then ?<br />
[00:16] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: I meant *internal* accel state. That one is probably mandatory to virtualize the accel engine.<br />
[00:16] &lt;<font color="red">philbo</font>&gt; <philbo> skids: but we don't really have a way of asking for room. And if we did have such a thing then saving is no real issue anymore as it would be handled automagically by the system for requesting room.<br />
[00:16] &lt;<font color="blue">skids</font>&gt; <skids> Then you take the 2/3rd second hit, but if you switch to text and back to same console, no 2/3rd second hit.<br />
[00:17] &lt;<font color="brown">Foske</font>&gt; <Foske> hmzz<br />
[00:17] &lt;<font color="blue">skids</font>&gt; <skids> philbo: we do have a way to ask for room, we just need to enhance it probably -- easier now with the ICOTL.<br />
[00:18] &lt;<font color="brown">Foske</font>&gt; <Foske> okay, requires communication with user level, but ok<br />
[00:18] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> * Why bother about saving fb if the application doesn't stop when it looses focus, no?<br />
[00:18] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> If VRAM room reservation is granted to userspace, then userspace should manage state saving...<br />
[00:18] &lt;<font color="blue">skids</font>&gt; <skids> nsouch: the app will have to stop, or it will get blocked.<br />
[00:19] &lt;<font color="green">bughunter</font>&gt; <bughunter> ... by libkgi...<br />
[00:19] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: IMO we MUST avoid relying on userspace scheduling to accomplish the state saving task during VC switch.<br />
[00:19] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> nsouch: saving the fb may be provided for convenience.<br />
[00:19] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> bughunter: at the next graphic access?<br />
[00:20] &lt;<font color="red">philbo</font>&gt; <philbo> skids: well, we could remap the mapped fb to the saved buffer and let the app continue drawing, only it would be to system memory.<br />
[00:20] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: yep. I agree. But userspace can use VRAM-room as a cache (keeping original content in main RAM). So it can provide state-saving without needing synchronisation with the kernel driver.<br />
[00:20] &lt;<font color="blue">skids</font>&gt; <skids> nsouch: right, the unmap() we were referring to that needs to be implemented causes a page fault when the app tries to use /dev/graphic when it has lost focus.<br />
[00:21] &lt;<font color="blue">skids</font>&gt; <skids> ANyway I think most of this is "for the future" talk and we should concentrate on madatory base KGI driver specs -- what should the mandatory base driver save?<br />
[00:21] &lt;<font color="red">philbo</font>&gt; <philbo> skids: I'd say only vga-text saving should be mandatory.<br />
[00:21] &lt;<font color="brown">Foske</font>&gt; <Foske> true skids...<br />
[00:21] &lt;<font color="blue">skids</font>&gt; <skids> IMO basically just the video mode, and some info to tell the app how much accel fifo content was destroyed.<br />
[00:21] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> skids: so even if the application executes, you can redirect it to the saved area.<br />
[00:21] &lt;<font color="brown">Foske</font>&gt; <Foske> ok<br />
[00:21] &lt;<font color="brown">Foske</font>&gt; <Foske> for KGI 1.0 :)<br />
[00:22] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: If userspace does not want to comply to such constraints, IMHO, it should not be allowed to reserve arbitrary VRAM space. (It has already got a fb. And I'd agree to save that in the kernel.)<br />
[00:23] &lt;<font color="blue">skids</font>&gt; <skids> nsouch: Yes, that's an option, but SW fallback would then have to be relinked by the app because in a lot of cases the chipset cannot support a text mode and have the GPU run, as the GPU draws some values from the registers shared by the CRTC/etc.<br />
[00:23] &lt;<font color="brown">Foske</font>&gt; <Foske> you know you run on a multitasking / multiterminal OS, so write decent software... :)<br />
[00:23] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: The driver should also provide some information to userspace (concerned to libgalloc)<br />
[00:24] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: when you mean saving the video mode, you mean the fb or only the mode parms?<br />
[00:24] &lt;<font color="blue">skids</font>&gt; <skids> bughunter: yeah, we'll cross that bridge when we actually get to that continent :-)<br />
[00:24] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: ok<br />
[00:25] &lt;<font color="brown">Foske</font>&gt; <Foske> to provide info, you first need info to provide<br />
[00:25] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: just the mode parms and palette.  Of course, I am not considering kernel vc's as merely an APP -- they get content and font, too.<br />
[00:25] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: I hope, libgalloc's X-target is ready then to be used as a reference target for the libkgi one.<br />
[00:26] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: ok. (add the cursor shape btw)<br />
[00:26] &lt;<font color="blue">skids</font>&gt; <skids> I am finding X more and more frustrating to work with and am wondering whether that was a good choice.<br />
[00:26] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: but of course! :-)<br />
[00:26] &lt;<font color="maroon">cow</font>&gt; <cow> how should userspace parts for ggi be provided? would it be possible to generate them, cleanly? or are those ment to be 'written'?<br />
[00:27] &lt;<font color="blue">skids</font>&gt; <skids> OK, so we need a list of what gets done 1) on VC switch from text to graph app, 2) on vc switch from graph app to text, and 3) graph-app to graph-app.<br />
[00:27] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> cow: what do you mean by "generate"?<br />
[00:27] &lt;<font color="green">bughunter</font>&gt; <bughunter> cow: The clean way to do that through libkgi.<br />
[00:27] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> bughunter, skids: we also need a list of the information userspace wants from the driver.<br />
[00:28] &lt;<font color="blue">skids</font>&gt; <skids> Oh, and 4) on monitor swap/mode reporgram.<br />
[00:28] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, generate them out of the kernel drivers<br />
[00:28] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: That's pretty much model-specific, so I's say we make it a free-form string.<br />
[00:28] &lt;<font color="brown">Foske</font>&gt; <Foske> skids: on monitor reprogram / modechange, you try not to change the virtual image size, even if the new monitor enforces a BIGGER image <br />
[00:28] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: except for the monitor part which we can standardize.<br />
[00:29] &lt;<font color="brown">Foske</font>&gt; <Foske> skids: so, nothing happens with your framebuffer then<br />
[00:29] &lt;<font color="green">bughunter</font>&gt; <bughunter> ortalo: GGI (libgalloc in particular) needs the information what the app must do to use a certain feature at all and what it can do else.<br />
[00:29] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> cow: userspace part and kernel part have pretty different functions, they are not so related. They probably only share the main hw-specific header file.<br />
[00:29] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> skids: which is close to vc switching finally<br />
[00:29] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, yes. ok<br />
[00:29] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: fully free-form? It means only hw-specific userspace can parse it?<br />
[00:30] &lt;<font color="blue">skids</font>&gt; <skids> Foske: right, even if the new monitor cannot do a mode "that small", it is easy enough to tweak the blanking settings to make a smaller mode with a big bloack border.<br />
[00:30] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: I would say yes, for now.<br />
[00:31] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: This makes things easier for fast development, and as standard forms become evident we can decide to standardize them to reduce the userspace code.<br />
[00:31] &lt;<font color="brown">Foske</font>&gt; <Foske> well... easy... easy........<br />
[00:31] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> bughunter: don't you want to lobby with me to convince skids to build a small standard info struct?<br />
[00:32] &lt;<font color="blue">skids</font>&gt; <skids> OK, not as easy from the userspace perspective, but which would you rather have an easy time at -- kernel programming or userspace programming :-)<br />
[00:32] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> (I'll really have to write that userspace code...)<br />
[00:32] &lt;<font color="green">bughunter</font>&gt; <bughunter> ortalo: In libkgi's API?<br />
[00:32] &lt;<font color="red">philbo</font>&gt; <philbo> skids: actually, that's what I used for the kgi target for libggi. Currently, every resource has a description string. So the name of the accelerator is assumed to be "<accelerator name> <accelerator specific stuff>" that way the name of the sublib loaded is given by the first word and the rest of the string can be parsed by the sublib<br />
[00:32] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: ok, true. But well...<br />
[00:32] &lt;<font color="blue">skids</font>&gt; <skids> Actually I'm a regular font of abstraction :-)<br />
[00:33] &lt;<font color="blue">skids</font>&gt; <skids> philbo: my thoughts exactly :-)<br />
[00:33] &lt;<font color="green">bughunter</font>&gt; <bughunter> ortalo: A _complete_ KGI driver consists of two parts: The kernel part and the userspace part (which is in libkgi like a libggi target)<br />
[00:33] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> bughunter: More precisely, for KGI kernel API.<br />
[00:33] &lt;<font color="brown">Foske</font>&gt; <Foske> yeah : abstraction is nice... the first hings that usually disappear when abstracting are the problems :)<br />
[00:33] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> ortalo, skids: no, in kernel, you don't have to know POSIX<br />
[00:33] &lt;<font color="blue">skids</font>&gt; <skids> I just don't think abstracting RIGHT NOW is appropriate.<br />
[00:34] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: if you feel like writing userspace code you might want to consider adding a matrox sublib to libggi.<br />
[00:35] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> philbo: I intend to. As soon as Matrox stop producing chipsets that do not work with my software...<br />
[00:35] &lt;<font color="red">philbo</font>&gt; <philbo> bughunter: why keep the libkgi part in there? libggi has all we need.<br />
[00:35] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> ortalo: or you get your soft working with their hw ;)<br />
[00:35] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: KGI is NOT intended to be only and only used by GGI.<br />
[00:35] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: maybe you should skip trying to get every chipset to work now, and focus on making the chipsets that DO work, work perfectly<br />
[00:35] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: Otherwise, each KGI user has to write its own userspace KGI driver...<br />
[00:36] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> It seems to me that libkgi really has a reole to play to avoid that driver writers produce similar code for handling common issues (such as mode-setting, info gathering, or for standard resources like cursor, etc.)<br />
[00:36] &lt;<font color="red">philbo</font>&gt; <philbo> bughunter: but then you have to create an interface for libkgi and I would not be surprised if you ended up creating a second libggi.<br />
[00:36] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Foske: Yep. But I'd like to do that on a widely available chipset and... first they deprecated the G200, then the G400, then the G450, then the G500...!<br />
[00:37] &lt;<font color="brown">Foske</font>&gt; <Foske> libkgi surely must adapt the API GGI can use easily IMHO<br />
[00:37] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: No, because libggi will have a libkgi target, which simply relies on libkgi.<br />
[00:38] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: The libkgi target replaces libggi's kgi-target finally.<br />
[00:38] &lt;<font color="brown">Foske</font>&gt; <Foske> ortalo: my opinion: stick to the G200, G400 and G450 till it works...<br />
[00:38] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: right.<br />
[00:38] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Foske: That's what I try to do in fact. Only the 50 needs some more work.<br />
[00:39] &lt;<font color="red">philbo</font>&gt; <philbo> I really don't see the need for libkgi. LibGGI was designed to be perfectly minimalistic and has a fabulous sublib loading system for providing chipset specific drivers and extensions for possible other interfaces which integrates well with the sublib system. That's exactly what the user-space of kgi should look like and adding another layer in between makes no sense to me.<br />
[00:39] &lt;<font color="brown">Foske</font>&gt; <Foske> imho, libKGI as a standalone project wa snonsense too<br />
[00:39] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> philbo: maybe that's just a problem with the name. As bughunter says, I speak most of the "kgi-target" in fact.<br />
[00:39] &lt;<font color="brown">Foske</font>&gt; <Foske> and PhoeniX should never have existed...<br />
[00:39] &lt;<font color="gray">golbez</font>&gt; <golbez> bughunter: I don't understand. If we're going to have a userspace library for kgi, why not use ggi?  Wasn't that the initial intention of ggi.. to be the userspace side of kgi?  I realise ggi have evolved since then but ...<br />
[00:41] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> golbez: Steffen Seeger want an additional intermediate layer between the libggi kgi-target and the KGI kernel drivers. This intermediate layer could have had several implementations.<br />
[00:41] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> golbez: s/want/wanted/<br />
[00:41] &lt;<font color="blue">skids</font>&gt; <skids> Let's work on GGI for now, and then decide later id we want KGI -- the work on LibGGI KGI target will be easy to reuse in LibKGI.<br />
[00:41] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> golbez: for me, the important thing is the "kgi-target" of libggi.<br />
[00:41] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: I fully agree.<br />
[00:43] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> That's mainly a naming problem, KGI target is clearer it seems.<br />
[00:43] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Didn't directfb take the role of kgi in ggi?<br />
[00:43] &lt;<font color="blue">skids</font>&gt; <skids> OK, I have a topic I want addressed before anyone scoots :-)<br />
[00:43] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> s/didn't/isn't<br />
[00:44] &lt;<font color="brown">Foske</font>&gt; <Foske> okay...<br />
[00:45] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> msg cow 'grins' means?<br />
[00:45] &lt;<font color="green">bughunter</font>&gt; <bughunter> nsouch: no. And directfb never will be.<br />
[00:45] &lt;<font color="brown">Foske</font>&gt; <Foske> so libKGI will be dropped for now as a separate target, and all focus will be on the GGI - KGI target<br />
[00:45] &lt;<font color="brown">Foske</font>&gt; <Foske> eh<br />
[00:45] &lt;<font color="brown">Foske</font>&gt; <Foske> as a separate project<br />
[00:46] &lt;<font color="maroon">cow</font>&gt; <cow> nsouch, i was referring to skids' ammunition consideration. anyway<br />
[00:46] &lt;<font color="brown">Foske</font>&gt; <Foske> who will work on the KGI target for GGI ?<br />
[00:46] &lt;<font color="brown">Foske</font>&gt; <Foske> I won't for sure :)<br />
[00:46] &lt;<font color="gray">golbez</font>&gt; <golbez> Foske: that's gone<br />
[00:46] &lt;<font color="blue">skids</font>&gt; <skids> me for one.<br />
[00:46] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Foske: why do you say as a separate project?<br />
[00:46] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: You're thinking about libkgi goes not far enough. You must think further to understand better.<br />
[00:47] &lt;<font color="brown">Foske</font>&gt; <Foske> I thought we just agreed we'll use ggi for the userlevel part<br />
[00:47] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Won't we loose Phoenix without libkgi maintained?<br />
[00:47] &lt;<font color="brown">Foske</font>&gt; <Foske> what is the use of PhoeniX ?<br />
[00:47] &lt;<font color="brown">Foske</font>&gt; <Foske> what does it provide XGGI doesn't ?<br />
[00:47] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> nsouch: IMO Phoenix can be made to work with libggi.<br />
[00:47] &lt;<font color="maroon">cow</font>&gt; <cow> nsouch, phoenix is dead. long live xggi<br />
[00:48] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> acceleration?<br />
[00:48] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Foske: different code base.<br />
[00:48] &lt;<font color="brown">Foske</font>&gt; <Foske> XGGI will do 3D accelleration in future<br />
[00:48] &lt;<font color="gray">golbez</font>&gt; <golbez> Foske: there is an updated kgi target in ggi cvs.  It should work with any kgi driver (needs the wip tree).<br />
[00:49] &lt;<font color="brown">Foske</font>&gt; <Foske> I hope, if not, GGI is doomed anyway<br />
[00:49] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> ortalo: a shame to kill it then<br />
[00:49] &lt;<font color="brown">Foske</font>&gt; <Foske> sure, but I told Steffen years ago that I didn't see the need for PhoeniX. And I still stay with that conclusion<br />
[00:49] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> golbez: XFree has developped its own approch to 2D accel and 3D accel. Maybe the code base upon which Phoenix is based could be easier to adapt to libggi.<br />
[00:50] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> golbez: keeping overhead of the driver infrastructure! Why?<br />
[00:50] &lt;<font color="blue">skids</font>&gt; <skids> OK, new topic, if I may: we should look to provide userspace system ram texture --> VRAM accelerated transfer ASAP after the basic functionality issues are worked out.<br />
[00:51] &lt;<font color="gray">golbez</font>&gt; <golbez> ortalo: that is an option too.<br />
[00:51] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: VRAM mmap or something else? (blitting from main memory to VRAM? pseudo-DMA?)<br />
[00:51] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> ortalo: yep!<br />
[00:52] &lt;<font color="gray">golbez</font>&gt; <golbez> nsouch: by using XFree we would have a widely maintained x server and one easily maintained driver<br />
[00:52] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> golbez: Pheonix code base remain to be studied (Steffen is/was the only one to know it well.)<br />
[00:52] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Well, enough on Phoenix I guess. We will look at it later, when the KGI target works.<br />
[00:53] &lt;<font color="red">philbo</font>&gt; <philbo> PhoeniX is a dead branch. The best way now would be to write a ggi module for XFree86 4.x This would be so very much more user friendly (just dropping a .o in the right directory)<br />
[00:54] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: the latter.<br />
[00:54] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: the kgi target does work.<br />
[00:54] &lt;<font color="blue">skids</font>&gt; <skids> It will give us an edge up on "the competition"<br />
[00:54] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: is memcopy() to (off fb) mmap()-ed portion of VRAM so slow?<br />
[00:55] &lt;<font color="blue">skids</font>&gt; <skids> Certainly slower than letting it be done by DMA><br />
[00:56] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: really slow. Things like movie playing can really benefit from DMA.<br />
[00:56] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Final note: I am not a fan of Phoenix, it's just I have doubts wrt XFree (it's such a beast).<br />
[00:56] &lt;<font color="green">bughunter</font>&gt; <bughunter> memcpy() data to VRAM --> never do this on a PPC!<br />
[00:56] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids, philbo: pseudo-DMA is not really DMA...<br />
[00:56] &lt;<font color="green">bughunter</font>&gt; <bughunter> ... due to internal cachings within the CPU.<br />
[00:56] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> bughunter: with hardware byte-swapping.<br />
[00:57] &lt;<font color="maroon">cow</font>&gt; <cow> bughunter, that's why skids want's to talk about translating to direct to direct blitting<br />
[00:57] &lt;<font color="blue">skids</font>&gt; <skids> bughunter: well that means LibGGI is pretty much broken on PPC, eh?<br />
[00:57] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: No, but the fbdev-target was. IIRC, Marcus Sundberg fixed it.<br />
[00:58] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> The problem with blitting from userspace to VRAM is having the userspace memory locked during the transfer, and allocated at proper place (e.g. with AGP constraints).<br />
[00:58] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: Yes (but I want to tackle the non-AGP case first.)<br />
[00:58] &lt;<font color="blue">skids</font>&gt; <skids> We have 2 options:<br />
[00:58] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> In fact, allocation is probably the biggest problem currently. KGI has to provide some "vramcapable_malloc()".<br />
[00:59] &lt;<font color="blue">skids</font>&gt; <skids> 1) The KGI driver allocates/maps RAM or 2) The KGI driver uses user app's mlocked RAM.<br />
[00:59] &lt;<font color="maroon">cow</font>&gt; <cow> protection-wise 2.4.19 is doable since it has a generic mprotect, as a sidenote<br />
[00:59] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: what about FreeBSD?<br />
[00:59] &lt;<font color="blue">skids</font>&gt; <skids> What does FreeBSD have in this area?<br />
[01:00] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> s/skids/nsouch/<br />
[01:00] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Option 2) is dangerous. If the RAM is not at the right place...<br />
[01:01] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, i don't think allocation is a problem. you will be able to set whichever constraints you want on the allocation<br />
[01:01] &lt;<font color="blue">skids</font>&gt; <skids> Right option 2) is also dangerous if the user unlocks/unallocs the RAM.<br />
[01:01] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> philbo, cow: plus the security constraints (easy DoS with many allocations).<br />
[01:02] &lt;<font color="brown">Foske</font>&gt; <Foske> it sure is far too complicated for me to follow at the moment... I should get some sleep<br />
[01:02] &lt;<font color="green">bughunter</font>&gt; <bughunter> option 2) would be a job for libkgi<br />
[01:02] &lt;<font color="blue">skids</font>&gt; <skids> But option 2) does have some good points in that it would make it easier for certain existing gl's to be retrofitted to use KGI.<br />
[01:02] &lt;<font color="blue">skids</font>&gt; <skids> and option 2) skirts the DoS issue because if a user can mlock too much RAM, that's the OSes problem, not KGI.<br />
[01:02] &lt;<font color="blue">skids</font>&gt; <skids> :-)<br />
[01:03] &lt;<font color="red">philbo</font>&gt; <philbo> We should move on for the sake of Europeans :-) Multihead: images or displays?<br />
[01:03] &lt;<font color="brown">Foske</font>&gt; <Foske> lol<br />
[01:04] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, true. i don't really feel like doing a rate limited allocator (wouldn't be too hard, i guess, but i don't see the point) as long as there's panic() or oom()<br />
[01:04] &lt;<font color="blue">skids</font>&gt; <skids> s/closer/closure/<br />
[01:04] &lt;<font color="brown">Foske</font>&gt; <Foske> *CLICK*<br />
[01:04] &lt;<font color="brown">Foske</font>&gt; <Foske> :)<br />
[01:04] &lt;<font color="green">bughunter</font>&gt; <bughunter> lol<br />
[01:04] &lt;<font color="brown">Foske</font>&gt; <Foske> Anyway...<br />
[01:04] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> BTW, when the accel engine channel is available, at least on the Matrox, blitting from userspace is feasible. All the driver needs to do is to do the virtual->physical translation in the command stream (involves parsing the command stream however).<br />
[01:05] &lt;<font color="brown">Foske</font>&gt; <Foske> IMHO Images<br />
[01:05] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: Not that that you click (or kick) off yourself... :)<br />
[01:05] &lt;<font color="brown">Foske</font>&gt; <Foske> /mode +b #kgi /me<br />
[01:06] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Did we get to next topic?<br />
[01:06] &lt;<font color="brown">Foske</font>&gt; <Foske> yes...<br />
[01:06] &lt;<font color="brown">Foske</font>&gt; <Foske> images or displays<br />
[01:06] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> IIRC multiple images were for stereo or double-buffering no?<br />
[01:07] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: images really fit so nicely. The only issue is that each image will have to have its own monitor limit calculation. I don't quite know where to hook that up (though at least the unified monitor driver will make it much simpler)<br />
[01:07] &lt;<font color="brown">Foske</font>&gt; <Foske> here, it really is getting late in Europe :)<br />
[01:07] &lt;<font color="blue">skids</font>&gt; <skids> I'm for images as well, just i think we need to put some thought into sharing the same display between multiple apps, each with their own image.<br />
[01:07] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: no, that's frames.<br />
[01:07] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Oops. Sorry.<br />
[01:07] &lt;<font color="brown">Foske</font>&gt; <Foske> I just heard you are writing that unified driver, so that's no problem =)<br />
[01:08] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Why not both possibilities?<br />
[01:08] &lt;<font color="green">bughunter</font>&gt; <bughunter> philbo: How about using one logical display? There you can hook up all the images.<br />
[01:08] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: Didn't you sleep some hours in the afternoon (as I did)?<br />
[01:09] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: well, sure I guess. It's just that multiple displays will require serious redesign of KGIM. I don't know if anybody's willing to do it.<br />
[01:09] &lt;<font color="brown">Foske</font>&gt; <Foske> bughunter: I suffer from ME, I sleep almost all day at the moment<br />
[01:09] &lt;<font color="blue">skids</font>&gt; <skids> philbo: maybe that diagram will help figure out what needs to change and how to get each image it's own mode management structures.<br />
[01:09] &lt;<font color="red">philbo</font>&gt; <philbo> bughunter: that's pretty much exactly what images give us.<br />
[01:09] &lt;<font color="teal">nsouch2</font>&gt; <nsouch2> just lost my connection :(, I'm back<br />
[01:10] &lt;<font color="brown">Foske</font>&gt; <Foske> oki<br />
[01:10] &lt;<font color="brown">Foske</font>&gt; <Foske> nsouch2: multihead: images or displays...<br />
[01:10] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> It seems images for multihead are the simpler way to go.<br />
[01:10] &lt;<font color="red">philbo</font>&gt; <philbo> skids: right. (BTW, they do have mode management structures, that's why they fit so nicely, it's just that there are assumptions in kgim structure about the fact that each display should have only one monitor. Not very many though)<br />
[01:10] &lt;<font color="brown">Foske</font>&gt; <Foske> what is against images ?<br />
[01:11] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: user space support. <br />
[01:11] &lt;<font color="teal">nsouch2</font>&gt; <nsouch2> they where not designed for this purpose<br />
[01:11] &lt;<font color="blue">skids</font>&gt; <skids> What if we changed to one /dev/graph per *image* ?<br />
[01:11] &lt;<font color="red">philbo</font>&gt; <philbo> nsouch2: I'm having trouble understanding what were they designed for<br />
[01:11] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: yes and no... now it's easier to see these images belong together in some way<br />
[01:12] &lt;<font color="red">philbo</font>&gt; <philbo> skids: I was thinking about that and it seems like a good idea, but a lot of work. I guess the advantage would be that even when that doesn't work it still would be quite useable.<br />
[01:12] &lt;<font color="gray">golbez</font>&gt; <golbez> skids: I think that would make it difficult to set up 2 images (or heads) into a single image<br />
[01:13] &lt;<font color="teal">nsouch2</font>&gt; <nsouch2> philbo: they look like filters<br />
[01:13] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: The more /dev/graph* files we need, the harder it becomes to convince Linus in future. (Linus won't add more major,minor numbers)<br />
[01:13] &lt;<font color="maroon">cow</font>&gt; <cow> skids, i always thought that the way to go was displays. apart from that, providing several 'targets' in /dev/graphic/* sounds nice<br />
[01:14] &lt;<font color="brown">Foske</font>&gt; <Foske> bughunter: I wonder if that still holds with the devfs system<br />
[01:14] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: I don't know. I don't wish.<br />
[01:14] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: that's right. It might not be such a big issue, if one thinks about what most people do with their dual head systems (I know its nice to think of all possibilities, but it might be important to concentrate on the most common scenario) very few people will hook up two keyboard and two mice to their multihead system and use it as two computers. Most likely they will use one program (X server most likely) that will control both heads,<br />
[01:14] &lt;<font color="red">philbo</font>&gt; <philbo> case there really is no problem.<br />
[01:14] &lt;<font color="brown">Foske</font>&gt; <Foske> bughunter: and we use one major number, only more minors<br />
[01:15] &lt;<font color="brown">Foske</font>&gt; <Foske> and we're not talking about claiming 1000's... only 2 or 3 more<br />
[01:15] &lt;<font color="maroon">cow</font>&gt; <cow> foske, bughunter, it's a fight for major numbers, which should be factored out anyways, for a clean system. so, as long as there are static major numbers, that's no problem<br />
[01:15] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> philbo: or they will play quake on one head and look at kde on the other<br />
[01:16] &lt;<font color="brown">Foske</font>&gt; <Foske> cow: we claimed one major, we still claim one major....<br />
[01:16] &lt;<font color="maroon">cow</font>&gt; <cow> foske, bughunter, an no problem with non static majors, too, of course<br />
[01:16] &lt;<font color="blue">skids</font>&gt; <skids> philbo: I always thought the purpose of the second monitor was to be able to watch those screen savers you miss because they only come on when you leave your system idle :-)<br />
[01:17] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Doesn't devfs provide some local numbering for huge drivers?<br />
[01:17] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> skids: :))<br />
[01:17] &lt;<font color="brown">Foske</font>&gt; <Foske> skids: never seen quake-360 ?<br />
[01:17] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: in which case the quake still runs as an X application (GLX) because you have only one keyboard and mouse and so you need the X server to manage who gets the input<br />
[01:18] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: Do you have a panorama-like screenshot?<br />
[01:18] &lt;<font color="blue">skids</font>&gt; <skids> Foske: I think GTA4 was rumored to slate multimonitor support for the PC version :-)<br />
[01:18] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: Triple head cards are so great for that, you don't get the disturbing seam right in the spot you look at the most.<br />
[01:18] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> philbo: you would use the GGI version of quake no? and the Qt-on-GGI version of KDE... :-)<br />
[01:19] &lt;<font color="brown">Foske</font>&gt; <Foske> nopez, sorry<br />
[01:19] &lt;<font color="brown">Foske</font>&gt; <Foske> anyway<br />
[01:19] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> philbo: do not talk me about triple head cards without specs...<br />
[01:19] &lt;<font color="brown">Foske</font>&gt; <Foske> where are we....<br />
[01:19] &lt;<font color="gray">golbez</font>&gt; <golbez> ortalo: you sound bitter about that ;)<br />
[01:19] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: triple head is just 4-head with one unplugged :-)<br />
[01:19] &lt;<font color="brown">Foske</font>&gt; <Foske> maybe we should quit here and focus on the things we already discussed...<br />
[01:19] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: ah. fair enough :-) Seriously, these are exactly the problems I have with exposing multihead as separate images. I'm hoping we can solve them through /dev/graphic.<br />
[01:20] &lt;<font color="blue">skids</font>&gt; <skids> ortalo: Or one mounted up for HUD :-)<br />
[01:20] &lt;<font color="blue">skids</font>&gt; <skids> Yeah, I have housemates that are hungry and want to order pizza.  I should be going.<br />
[01:20] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> skids: how many combinations with 2 DDC1 and 1 DDC monitor?<br />
[01:20] &lt;<font color="red">philbo</font>&gt; <philbo> nsouch: I wish we had Steffen to explain images purpose. I'm not sure they are filters, isn't that the purpose of the dot stream converters (DSC) ?<br />
[01:20] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> I've just forwarded a mail to the list that was never received, about multihead. Actually, I definitely think kgim shall handle multihead.<br />
[01:20] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> I think Foske is right. What do we decide?<br />
[01:21] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> has this discussion been recorded? Stupid, certainly.<br />
[01:21] &lt;<font color="brown">Foske</font>&gt; <Foske> I'll extract some sort of " who does what" tomorrow and mail it to the mailinglist<br />
[01:21] &lt;<font color="gray">golbez</font>&gt; <golbez> nsouch: it has been logged<br />
[01:22] &lt;<font color="brown">Foske</font>&gt; <Foske> even twice :)<br />
[01:22] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: Not necessarily. If you have one 2-headed and one 1-headed card, then triple head is NOT 4-headed with one unplugged. :)<br />
[01:22] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> philbo: kgi/doc/kgi.sgml addresses images. At least, I understood it is not for multihead.<br />
[01:22] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> I want a 4-port Matrox too. With specs.<br />
[01:22] &lt;<font color="brown">Foske</font>&gt; <Foske> if the US is Nuked, we still got a log in Europe :)<br />
[01:23] &lt;<font color="brown">Foske</font>&gt; <Foske> mea culpa<br />
[01:23] &lt;<font color="gray">golbez</font>&gt; <golbez> US junior<br />
[01:23] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> 4 specs.<br />
[01:23] &lt;<font color="brown">Foske</font>&gt; <Foske> "teh other side of that shitty sea"<br />
[01:23] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: great. People can respond to that and make commitments. <br />
[01:23] &lt;<font color="blue">skids</font>&gt; <skids> Foske: Tell the CIA agents I said hi when they come knocking :-)<br />
[01:23] &lt;<font color="blue">skids</font>&gt; <skids> Foske: Actualy, don't :-)<br />
[01:24] &lt;<font color="brown">Foske</font>&gt; <Foske> okay<br />
[01:24] &lt;<font color="green">bughunter</font>&gt; <bughunter> skids: Should I do for him? ;-)<br />
[01:24] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: you and I focus on the monitor driver ?<br />
[01:24] &lt;<font color="brown">Foske</font>&gt; <Foske> CIA already knows now<br />
[01:24] &lt;<font color="brown">Foske</font>&gt; <Foske> All my IP traffic is logged<br />
[01:25] &lt;<font color="maroon">cow</font>&gt; <cow> so.... philbo and golbez will look at multihead by means of images first.<br />
[01:25] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: You're kidding?<br />
[01:25] &lt;<font color="gray">golbez</font>&gt; <golbez> cow: k<br />
[01:25] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: I'd like to give DDC2 a try if I could init Matrox DDC2 without the whole chipset/kgi running.<br />
[01:25] &lt;<font color="maroon">cow</font>&gt; <cow> bughunter, wish he was ;)<br />
[01:26] &lt;<font color="brown">Foske</font>&gt; <Foske> the libggi stuff is done by ...<br />
[01:26] &lt;<font color="green">bughunter</font>&gt; <bughunter> CIA? :)<br />
[01:26] &lt;<font color="red">philbo</font>&gt; <philbo> Foske, cow: ok.<br />
[01:26] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> FreeBSD/KGI was not addressed, it will when there will be something visible ;)<br />
[01:26] &lt;<font color="brown">Foske</font>&gt; <Foske> bughunter: I work for the Dutch KLPD (Sort of FBI)<br />
[01:26] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> I'll have to do the Matrox-specific libggi stuff.<br />
[01:26] &lt;<font color="maroon">cow</font>&gt; <cow> golbez, if you think it's viable. i don't know<br />
[01:26] &lt;<font color="brown">Foske</font>&gt; <Foske> Kind of too<br />
[01:27] &lt;<font color="brown">Foske</font>&gt; <Foske> okay<br />
[01:27] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: golbez and I did the basic libggi stuff. I also have a mach64 sublib for ggi yet to commit.<br />
[01:27] &lt;<font color="brown">Foske</font>&gt; <Foske> I take care of the DDC2 implementation besides the generic monitor driver cleanup<br />
[01:27] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> We need steffen point of view for the multihead issue. He's finishing is PhD.<br />
[01:27] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: your mach64 driver in thw wip tree is up to date ?<br />
[01:28] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> philbo: I'll take insipiration from the mach64 sublib for the Matrox one (understand: steal the code) as soon as I'm done with these stupid PLL transistors.<br />
[01:28] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> And the ->wip transition.<br />
[01:28] &lt;<font color="red">philbo</font>&gt; <philbo> nsouch: I know. I wish there was a way to get an "emergency" mail to him. Maybe I'll just have to get a plane ticket to germany :)<br />
[01:28] &lt;<font color="brown">Foske</font>&gt; <Foske> isn't too far from France :)<br />
[01:29] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> I got an answer from Steffen on August 19. At least, he's still alive.<br />
[01:29] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: It is up to date but not complete. I have some usability issues to address. (and the DDC stuff isn't there either)<br />
[01:29] &lt;<font color="blue">skids</font>&gt; <skids> Foske: and these days, you could probably get there by boat :-/<br />
[01:29] &lt;<font color="maroon">cow</font>&gt; <cow> i'll listen to skids and perhaps do other stuff too, fwiw<br />
[01:29] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: true<br />
[01:29] &lt;<font color="brown">Foske</font>&gt; <Foske> of course... you and I will take a look at the interface issues when working on the monitor driver, ok ?<br />
[01:30] &lt;<font color="red">philbo</font>&gt; <philbo> Anybody volunteered to look into VC switching?<br />
[01:30] &lt;<font color="brown">Foske</font>&gt; <Foske> that was for philbo<br />
[01:30] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> The mail Nicolas forwarded seems interesting wrt image/display thing. Maybe this issue can be further debated on the list.<br />
[01:30] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> ortalo: I got one from today! "I currently finish (writing) my PhD, so I will probably be more active again<br />
[01:30] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> in a few months. (At least I hope)."<br />
[01:30] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> ... said steffen.<br />
[01:30] &lt;<font color="brown">Foske</font>&gt; <Foske> in a few MONTHS ???<br />
[01:30] &lt;<font color="brown">Foske</font>&gt; <Foske> gee<br />
[01:30] &lt;<font color="brown">Foske</font>&gt; <Foske> long PhD doc<br />
[01:31] &lt;<font color="gray">golbez</font>&gt; <golbez> nsouch: that's good news!<br />
[01:31] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Foske: :) no, good PhD doc<br />
[01:31] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Foske: It's usually 6 months to write the PhD and then 3 months latency before defending it in front of a jury. I guess he is at the end of the writing.<br />
[01:31] &lt;<font color="green">bughunter</font>&gt; <bughunter> better late than never.<br />
[01:31] &lt;<font color="brown">Foske</font>&gt; <Foske> anyway...<br />
[01:31] &lt;<font color="brown">Foske</font>&gt; <Foske> still important remarks ?<br />
[01:32] &lt;<font color="brown">Foske</font>&gt; <Foske> otherwise I go to bed<br />
[01:32] &lt;<font color="brown">Foske</font>&gt; <Foske> 01:32 here<br />
[01:32] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Which Matrox model has 4 ports?<br />
[01:32] &lt;<font color="red">philbo</font>&gt; <philbo> I guess nobody wants to touch vcs...<br />
[01:32] &lt;<font color="brown">Foske</font>&gt; <Foske> I'll keep the log on so I don't miss a thing<br />
[01:32] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> 01:28 here, damn jetlag...<br />
[01:32] &lt;<font color="brown">Foske</font>&gt; <Foske> :)<br />
[01:32] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: Your clock goes a wrong a little. Your clock is about 4 mintues ahead.<br />
[01:33] &lt;<font color="red">philbo</font>&gt; <philbo> I'll try looking into the map/unmap issues but I promise no results :-)<br />
[01:33] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> Worse here, 1:34<br />
[01:33] &lt;<font color="brown">Foske</font>&gt; <Foske> bughunter: can be.. my clock synchronisation hack doesn't work anymore (synced my PC with my VCR)<br />
[01:34] &lt;<font color="slategray">nsouch</font>&gt; <nsouch> So bye, see you on the list.<br />
[01:34] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> VC switch?<br />
[01:34] &lt;<font color="brown">Foske</font>&gt; <Foske> night everyone :)<br />
[01:34] &lt;<font color="brown">Foske</font>&gt; <Foske> see you<br />
[01:34] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> any candidate?<br />
[01:34] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: you should use and official ntp server<br />
[01:34] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: sleep well<br />
[01:34] &lt;<font color="green">bughunter</font>&gt; <bughunter> :)<br />
[01:34] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Well, I'll try to think to that.<br />
[01:34] &lt;<font color="brown">Foske</font>&gt; <Foske> philbo: naah, as an Electrical Engineer, this is more fun...<br />
[01:34] &lt;<font color="red">philbo</font>&gt; <philbo> Foske: g'night<br />
[01:35] &lt;<font color="brown">Foske</font>&gt; <Foske> Foske &<br />
[01:35] &lt;<font color="red">philbo</font>&gt; <philbo> lol<br />
[01:35] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Have a good night too (or maybe evening?)<br />
[01:35] &lt;<font color="green">bughunter</font>&gt; <bughunter> Foske: Don't press CTRL + Z :)<br />
[01:36] &lt;<font color="green">bughunter</font>&gt; <bughunter> ortalo: evening? I would say, good morning :)<br />
[01:36] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Everything was simpler when the earth was flat...<br />
[01:37] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Well, I really need to go to bed.<br />
[01:37] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> I'm only saying stupid things.<br />
[01:37] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> (BTW, things were also simpler when Matrox boards only had one head.)<br />
[01:37] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: hehe<br />
[01:37] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, good night<br />
[01:37] &lt;<font color="green">bughunter</font>&gt; <bughunter> ortalo: Let's start as a pyjama party! :)<br />
[01:37] &lt;<font color="red">philbo</font>&gt; <philbo> ortalo: night<br />
[01:37] &lt;<font color="maroon">cow</font>&gt; <cow> ortalo, that's true 8)<br />
[01:38] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> Good bye. At least, my little boy had a very nice dinner... Thanks for him.<br />
[01:38] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> (And he went to bed early. Lucky boy.)<br />
[01:38] &lt;<font color="gray">golbez</font>&gt; <golbez> g'night Europe<br />
[01:39] &lt;<font color="indigo">ortalo</font>&gt; <ortalo> g'night America<br />
<h3>Participants</h3>
<table>
<tr><th>Nick</th><th>First occurence at</th><th>Number of messages</th></tr>
<tr bgcolor="brown"><td><font color="white">Foske</font></td><td><font color="white">23:01:</font></td><td><font color="white">182</tr>
<tr bgcolor="green"><td><font color="white">bughunter</font></td><td><font color="white">23:01:</font></td><td><font color="white">50</tr>
<tr bgcolor="maroon"><td><font color="white">cow</font></td><td><font color="white">23:02:</font></td><td><font color="white">38</tr>
<tr bgcolor="purple"><td><font color="white">curtisv</font></td><td><font color="white">23:11:</font></td><td><font color="white">4</tr>
<tr bgcolor="gray"><td><font color="white">golbez</font></td><td><font color="white">23:10:</font></td><td><font color="white">18</tr>
<tr bgcolor="darkcyan"><td><font color="white">hunger</font></td><td><font color="white">23:41:</font></td><td><font color="white">2</tr>
<tr bgcolor="slategray"><td><font color="white">nsouch</font></td><td><font color="white">23:16:</font></td><td><font color="white">48</tr>
<tr bgcolor="teal"><td><font color="white">nsouch2</font></td><td><font color="white">01:09:</font></td><td><font color="white">3</tr>
<tr bgcolor="indigo"><td><font color="white">ortalo</font></td><td><font color="white">23:21:</font></td><td><font color="white">95</tr>
<tr bgcolor="red"><td><font color="white">philbo</font></td><td><font color="white">23:01:</font></td><td><font color="white">85</tr>
<tr bgcolor="blue"><td><font color="white">skids</font></td><td><font color="white">23:01:</font></td><td><font color="white">99</tr>
</table>
</body></html>
